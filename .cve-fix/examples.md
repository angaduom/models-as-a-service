# CVE Fix Examples - models-as-a-service

**Repository:** opendatahub-io/models-as-a-service
**Primary Language:** Go
**Last Updated:** February 19, 2026

## Repository Context

This repository has a **dual-build strategy** that critically affects CVE remediation:

1. **Development Builds** (quay.io/opendatahub/maas-api)
   - Built from `main` branch
   - Uses `maas-api/Dockerfile`
   - Base image: Floating tag (`:1.25`)
   - Auto-receives security updates

2. **Production Builds** (registry.redhat.io/rhoai/odh-maas-api-rhel9)
   - Built from `rhoai`/`stable` branches
   - Uses `maas-api/Dockerfile.konflux`
   - Base image: Pinned SHA (`@sha256:...`)
   - Requires manual updates for security patches

**Critical Impact:** A CVE may be fixed in development but still affect production, or vice versa. ALWAYS check both build systems when investigating CVEs.

---

## Pattern 1: Go Standard Library CVEs

### Overview

**Frequency:** Common when Go stdlib vulnerabilities are disclosed
**Fix Complexity:** Low (version bump, typically no code changes)
**Critical Insight:** MUST use `govulncheck --mode binary` for accurate detection

Go standard library CVEs affect the compiled runtime, not just source code. Source scanning tools will miss these vulnerabilities because they analyze imports and dependencies, not the actual Go version compiled into the binary.

### Historical Example: CVE-2025-61729 & CVE-2025-68121 (February 2026)

**Date:** February 2026
**Jira Tickets:** RHOAIENG-44788, RHOAIENG-49745
**Affected Packages:** crypto/x509, crypto/tls in Go 1.25.3
**Fix Version:** Go 1.25.7
**Resolution:** Update go-toolset base image SHA in Dockerfile.konflux

#### CVE Details

- **CVE-2025-61729** (GO-2025-4155)
  - Package: crypto/x509
  - Type: Resource consumption vulnerability
  - CVSS: 7.5 (High)
  - Fixed in: Go 1.25.5+

- **CVE-2025-68121** (GO-2026-4337)
  - Package: crypto/tls
  - Type: Session resumption vulnerability
  - CVSS: 7.5 (High)
  - Fixed in: Go 1.25.7+

**Additional CVEs discovered during investigation:**
- CVE-2025-61727: crypto/x509 wildcard validation
- CVE-2025-61730: crypto/tls handshake encryption
- CVE-2025-61726: net/url memory exhaustion
- CVE-2025-61728: archive/zip CPU consumption

All six CVEs were resolved by updating to Go 1.25.7.

### Problem Description

During CVE investigation, we discovered:

1. **Initial Report:** CVE-2025-61729 and CVE-2025-68121 affecting maas-api
2. **Confusion:** Why is quay.io/opendatahub/maas-api:latest showing as fixed, but registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2 still vulnerable?
3. **Investigation Required:** Needed to understand the discrepancy between registries

### Root Cause Analysis: The Two-Dockerfile Problem

#### Dockerfile (Development) - FIXED ✅

**File:** `maas-api/Dockerfile`
**Used by:** quay.io/opendatahub/maas-api builds
**Strategy:** Floating tag

```dockerfile
ARG GOLANG_VERSION=1.25
FROM registry.access.redhat.com/ubi9/go-toolset:${GOLANG_VERSION} AS builder
```

**Behavior:**
- Uses tag `:1.25` which Red Hat continuously updates
- When Red Hat released Go 1.25.7, the `:1.25` tag automatically pointed to it
- New builds automatically received the fix
- **Current Go Version:** 1.25.7 ✅ FIXED

#### Dockerfile.konflux (Production) - VULNERABLE ⚠️

**File:** `maas-api/Dockerfile.konflux`
**Used by:** registry.redhat.io/rhoai/* builds
**Strategy:** Pinned SHA

```dockerfile
ARG GOLANG_VERSION=1.25
FROM --platform=$BUILDPLATFORM registry.access.redhat.com/ubi9/go-toolset@sha256:eaa6e2e560935e4b19c6c877d679c4b48b5dd7d9f87c3d6aa141d03da7bf0815 AS builder
```

**Behavior:**
- Uses pinned SHA `eaa6e2e560935...` set on December 15, 2025
- This SHA contains Go 1.25.3
- Even when Red Hat updated the `:1.25` tag to Go 1.25.7, the pinned SHA remained unchanged
- Production builds stayed on Go 1.25.3
- **Current Go Version:** 1.25.3 ⚠️ VULNERABLE

#### Why This Happened: Timeline

1. **December 15, 2025** - Commit 3cf4c9b by Bartosz Majsak
   - Bumped Go from 1.24 to 1.25
   - Updated Dockerfile.konflux to SHA `eaa6e2e560935...` (Go 1.25.3)
   - This was the latest available at the time

2. **December 2025** - Go security releases
   - Go 1.25.5 released with fix for CVE-2025-61729
   - Red Hat updated `:1.25` tag, but pinned SHA unchanged

3. **February 2026** - Additional Go security releases
   - Go 1.25.7 released with fix for CVE-2025-68121
   - Red Hat updated `:1.25` tag to Go 1.25.7
   - **Development builds (Dockerfile):** Automatically got 1.25.7 ✅
   - **Production builds (Dockerfile.konflux):** Still stuck on 1.25.3 ⚠️

### Step-by-Step Fix Procedure

#### Step 1: Verify CVE Presence with Binary Scanning

**CRITICAL:** Use `--mode binary`, NOT source scanning. Source scanning will NOT detect Go stdlib version vulnerabilities.

```bash
# Pull the suspected vulnerable image
docker pull registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2

# Extract the binary from the container
CONTAINER_ID=$(docker create registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/maas-api-binary
docker rm "$CONTAINER_ID"

# Scan the binary for vulnerabilities (OpenVEX format for machine-readability)
govulncheck --mode binary --format openvex /tmp/maas-api-binary > vuln-report.json

# Check for specific CVEs
jq '.statements[] | select(.vulnerability.aliases[]? | contains("CVE-2025-61729"))' vuln-report.json
jq '.statements[] | select(.vulnerability.aliases[]? | contains("CVE-2025-68121"))' vuln-report.json

# Also verify Go version in the binary
strings /tmp/maas-api-binary | grep "go1\."
```

**Expected Output (if vulnerable):**
```
go1.25.3 (Red Hat 1.25.3-1.el9_7) X:strictfipsruntime
```

**Expected OpenVEX Output (if vulnerable):**
```json
{
  "vulnerability": {
    "name": "GO-2025-4155",
    "aliases": ["CVE-2025-61729"],
    ...
  },
  "status": "affected"
}
```

#### Step 2: Identify Required Go Version

**Research the fix:**
1. Check Go security announcements: https://groups.google.com/g/golang-announce
2. Check Go CVE database: https://pkg.go.dev/vuln/
3. Identify minimum Go version that includes the fix

**For our CVEs:**
- CVE-2025-61729: Fixed in Go 1.25.5+
- CVE-2025-68121: Fixed in Go 1.25.7+
- **Required version:** Go 1.25.7 or later (must satisfy BOTH)

#### Step 3: Get SHA for Fixed Go Version

**Pull and inspect the latest go-toolset tag:**

```bash
# Pull the latest :1.25 tag
docker pull registry.access.redhat.com/ubi9/go-toolset:1.25

# Get the SHA digest for this tag
docker inspect registry.access.redhat.com/ubi9/go-toolset:1.25 | jq -r '.[0].RepoDigests[0]'
```

**Expected Output:**
```
registry.access.redhat.com/ubi9/go-toolset@sha256:799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc
```

**CRITICAL: Verify the Go version in this SHA:**

```bash
docker run --rm registry.access.redhat.com/ubi9/go-toolset@sha256:799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc go version
```

**Expected Output:**
```
go version go1.25.7 (Red Hat 1.25.7-1.el9_7) linux/amd64
```

**Verify this meets your requirements:**
- Go 1.25.7 >= Go 1.25.5 (CVE-2025-61729 fix) ✅
- Go 1.25.7 >= Go 1.25.7 (CVE-2025-68121 fix) ✅

#### Step 4: Update Dockerfile.konflux

**Edit the file:**

```bash
# Navigate to repository
cd /tmp/models-as-a-service

# Checkout appropriate branch
git checkout main  # For v3.3+
# OR
git checkout rhoai  # For backport to v3.2

# Edit the file
vim maas-api/Dockerfile.konflux
```

**Make this change:**

```diff
-FROM --platform=$BUILDPLATFORM registry.access.redhat.com/ubi9/go-toolset@sha256:eaa6e2e560935e4b19c6c877d679c4b48b5dd7d9f87c3d6aa141d03da7bf0815 AS builder
+FROM --platform=$BUILDPLATFORM registry.access.redhat.com/ubi9/go-toolset@sha256:799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc AS builder
```

**Summary of change:**
- **Old SHA** (Go 1.25.3): `eaa6e2e560935e4b19c6c877d679c4b48b5dd7d9f87c3d6aa141d03da7bf0815`
- **New SHA** (Go 1.25.7): `799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc`

**NO APPLICATION CODE CHANGES REQUIRED!** This is a stdlib-only fix.

#### Step 5: Verify the Fix

**Build a test image:**

```bash
# Build using the updated Dockerfile.konflux
docker build -f maas-api/Dockerfile.konflux -t maas-api:test .
```

**Extract and verify the binary:**

```bash
# Extract the binary from the test image
CONTAINER_ID=$(docker create maas-api:test)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/maas-api-fixed
docker rm "$CONTAINER_ID"

# Verify Go version
strings /tmp/maas-api-fixed | grep "go1\."
```

**Expected Output:**
```
go1.25.7 (Red Hat 1.25.7-1.el9_7) X:strictfipsruntime
```

**Scan for CVEs:**

```bash
govulncheck --mode binary /tmp/maas-api-fixed
```

**Expected Output:**
```
No vulnerabilities found.
```

**Or if there are unrelated vulnerabilities, confirm the target CVEs are NOT present:**

```bash
govulncheck --mode binary --format openvex /tmp/maas-api-fixed > fixed-report.json

# These should return empty (no results)
jq '.statements[] | select(.vulnerability.aliases[]? | contains("CVE-2025-61729"))' fixed-report.json
jq '.statements[] | select(.vulnerability.aliases[]? | contains("CVE-2025-68121"))' fixed-report.json
```

#### Step 6: Commit Message Guidelines

**IMPORTANT:** Follow these commit message rules when creating commits for CVE fixes:

**Conventional Commits Format:**
- use conventional commits format
- allowed types include: `feat`, `fix`, `build`, `chore`, `ci`, `docs`, `style`, `test`, `perf`, `refactor`, and others if needed
- for CVE fixes, typically use `fix` or `security` as the type
- align the commit title and body with the project's specification, codebase, and semantics
- use present tense in both the title and the body (e.g., "fix cve" not "fixed cve")
- keep the commit title under 60 characters
- **use only lowercase letters in both the title and the entire body of the commit message**
- ensure the body clearly explains what and why, not just how
- avoid vague messages like "update code" or "fix issue"

**Example Format:**
```
fix: cve-2025-61729 and cve-2025-68121 in go stdlib

update go-toolset base image from go 1.25.3 to go 1.25.7 to resolve
critical crypto vulnerabilities in go standard library.

cve details:
- cve-2025-61729: crypto/x509 resource consumption (cvss 7.5)
- cve-2025-68121: crypto/tls session resumption (cvss 7.5)

resolves: rhoaieng-44788, rhoaieng-49745

co-authored-by: claude sonnet 4.5 <noreply@anthropic.com>
```

**Key Points:**
- entire title must be lowercase, including type prefix (e.g., `fix:` not `Fix:`)
- title should be concise and descriptive (under 60 characters)
- all text in title and body must be lowercase
- body should explain the problem, solution, and verification
- include jira ticket references
- use consistent formatting throughout

#### Step 7: Create Branch and Commit Changes

**Fork the repository and create a branch:**

```bash
# Fork the repository on GitHub first (via web UI or gh CLI)
gh repo fork opendatahub-io/models-as-a-service --clone=false

# If you haven't cloned your fork yet:
# git clone https://github.com/YOUR-USERNAME/models-as-a-service.git
# cd models-as-a-service

# Add upstream remote (if not already added)
git remote add upstream https://github.com/opendatahub-io/models-as-a-service.git

# Fetch latest from upstream
git fetch upstream

# Create a branch from upstream/main (or upstream/rhoai for backports)
git checkout -b fix/cve-2025-61729-68121-go-stdlib upstream/main

# Stage the changes
git add maas-api/Dockerfile.konflux

# Create a comprehensive commit message following conventional commits
git commit -m "$(cat <<'EOF'
fix: cve-2025-61729 and cve-2025-68121 in go stdlib

update go-toolset base image from go 1.25.3 to go 1.25.7 to resolve
critical crypto vulnerabilities in go standard library.

cve details:
- cve-2025-61729: crypto/x509 resource consumption (cvss 7.5)
- cve-2025-68121: crypto/tls session resumption (cvss 7.5)

root cause:
dockerfile.konflux used a pinned sha pointing to go 1.25.3. while the
:1.25 floating tag was updated to go 1.25.7, the pinned sha remained
on the vulnerable version.

changes:
- update dockerfile.konflux pinned sha
- old sha (go 1.25.3): eaa6e2e560935e4b19c6c877d679c4b48b5dd7d9f87c3d6aa141d03da7bf0815
- new sha (go 1.25.7): 799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc

no application code changes required - stdlib-only fix.

verification:
- built test image with new sha
- extracted binary and verified go version: go1.25.7
- ran govulncheck --mode binary: both cves resolved
- confirmed no new vulnerabilities introduced

resolves: rhoaieng-44788, rhoaieng-49745

co-authored-by: claude sonnet 4.5 <noreply@anthropic.com>
EOF
)"
```

**Push to your fork and create PR:**

```bash
# Push the branch to your fork
git push -u origin fix/cve-2025-61729-68121-go-stdlib

# Create PR from your fork to upstream using gh CLI
gh pr create \
  --repo opendatahub-io/models-as-a-service \
  --base main \
  --head YOUR-USERNAME:fix/cve-2025-61729-68121-go-stdlib \
  --title "fix: cve-2025-61729 and cve-2025-68121 in go stdlib" \
  --body "$(cat <<'EOF'
## summary

updates go-toolset base image sha in dockerfile.konflux from go 1.25.3 to go 1.25.7 to resolve two critical crypto vulnerabilities.

## cve details

- **cve-2025-61729** (go-2025-4155): crypto/x509 resource consumption (cvss 7.5)
- **cve-2025-68121** (go-2026-4337): crypto/tls session resumption (cvss 7.5)

## root cause

the production dockerfile (dockerfile.konflux) uses a pinned sha that pointed to go 1.25.3. while red hat updated the `:1.25` floating tag to go 1.25.7, our pinned sha remained on the vulnerable version.

development builds (using floating tag in dockerfile) were automatically fixed, but production builds (using pinned sha in dockerfile.konflux) remained vulnerable.

## changes

- updated `maas-api/dockerfile.konflux` base image sha
- old: go 1.25.3 (`sha256:eaa6e2e560935...`)
- new: go 1.25.7 (`sha256:799cc027d5ad5...`)
- no application code changes required

## test plan

- [x] built test image with updated dockerfile.konflux
- [x] extracted binary and verified go version: `go1.25.7`
- [x] ran `govulncheck --mode binary` on test binary
- [x] confirmed cve-2025-61729 not present
- [x] confirmed cve-2025-68121 not present
- [x] verified no new vulnerabilities introduced
- [ ] ci/cd pipeline passes
- [ ] qe verification of production builds

## jira

- resolves: rhoaieng-44788
- resolves: rhoaieng-49745

generated with [claude code](https://claude.com/claude-code)
EOF
)"
```

### Recommended Approach: Pinned SHA with Regular Updates

**Strategy:** Use pinned SHAs for production reproducibility, but establish a regular security update process.

#### Why Pinned SHAs for Production?

**Advantages:**
- **Reproducible builds:** Same SHA always produces identical output
- **Change control:** Explicit approval for base image updates
- **Regression prevention:** Can test thoroughly before rollout
- **Compliance:** Meets requirements for auditable, deterministic builds

**Trade-offs:**
- Requires manual updates when security patches released
- Can lag behind security fixes if process is not followed
- Requires monitoring Go security announcements

#### Recommended Process

**1. Monitor Go Security Announcements**

Subscribe to:
- Go security mailing list: https://groups.google.com/g/golang-announce
- Go vulnerability database: https://pkg.go.dev/vuln/
- Red Hat security advisories for go-toolset

**2. Rapid Response for Security Updates**

When a Go security release is announced:

**Same Day:**
1. Check if vulnerability affects this project
2. Identify minimum Go version required for fix
3. Pull latest go-toolset tag and verify Go version
4. Get new SHA using the commands in Step 3

**Within 24 Hours:**
5. Update Dockerfile.konflux with new SHA
6. Build and test locally
7. Run full govulncheck verification
8. Create PR with detailed security context

**Within 48 Hours:**
9. Get PR reviewed and approved
10. Merge to appropriate branch(es)
11. Verify CI/CD builds successfully
12. Update JIRA tickets

**3. Regular SHA Review Cycle**

Even without security announcements, review quarterly:
- Check if newer Go patch versions available
- Update SHAs to stay current
- Test thoroughly before merging

**4. Document Each Update**

Maintain a history table (see Repository-Specific Notes section):

| Date | Commit | Old Version | New Version | Reason |
|------|--------|-------------|-------------|--------|
| Dec 15, 2025 | 3cf4c9b | Go 1.24 | Go 1.25.3 | Version bump to 1.25 |
| Feb 19, 2026 | TBD | Go 1.25.3 | Go 1.25.7 | CVE-2025-61729, CVE-2025-68121 |

#### Why NOT Floating Tags for Production?

While floating tags (`:1.25`) provide automatic updates, they have critical drawbacks for production:

**Risks:**
- Unpredictable changes in builds over time
- Cannot reproduce old builds exactly
- Security/compliance audits require deterministic builds
- Harder to identify what changed when issues arise

**When to Use Floating Tags:**
- Development environments (main branch)
- CI/CD test environments
- Rapid prototyping

**Hybrid Approach (Current Strategy):**
- Development (Dockerfile): Floating tags for automatic updates
- Production (Dockerfile.konflux): Pinned SHAs with regular review

This balances security (dev catches issues early) with stability (prod is reproducible).

---

## Testing Requirements

### Pre-Fix Testing (Confirming Vulnerability)

**Binary Extraction and Scanning (MANDATORY):**

```bash
# Extract binary from suspected vulnerable container
docker pull <registry>/<image>:<tag>
CONTAINER_ID=$(docker create <registry>/<image>:<tag>)
docker cp "$CONTAINER_ID:/app/<binary-name>" /tmp/<binary-name>
docker rm "$CONTAINER_ID"

# Scan with binary mode
govulncheck --mode binary /tmp/<binary-name>

# For machine-readable output
govulncheck --mode binary --format openvex /tmp/<binary-name> > vuln-report.json
```

**Go Version Verification:**

```bash
# Check Go version compiled into binary
strings /tmp/<binary-name> | grep "go1\."

# Expected format:
# go1.25.3 (Red Hat 1.25.3-1.el9_7) X:strictfipsruntime
```

**Document Baseline:**
- Go version found
- CVEs detected
- Vulnerable symbols/functions
- Save scan output for comparison

### Post-Fix Testing (Confirming Resolution)

**Build Validation:**

```bash
# Build with updated Dockerfile.konflux
docker build -f maas-api/Dockerfile.konflux -t maas-api:test .

# Verify build succeeds
echo $?  # Should be 0
```

**Binary Verification:**

```bash
# Extract binary from test build
CONTAINER_ID=$(docker create maas-api:test)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/maas-api-fixed
docker rm "$CONTAINER_ID"

# Verify Go version
strings /tmp/maas-api-fixed | grep "go1\."

# Should show new version, e.g.:
# go1.25.7 (Red Hat 1.25.7-1.el9_7) X:strictfipsruntime
```

**CVE Re-Scan:**

```bash
# Scan fixed binary
govulncheck --mode binary /tmp/maas-api-fixed

# Target CVEs should NOT appear
# For specific CVE check:
govulncheck --mode binary --format openvex /tmp/maas-api-fixed > fixed-report.json
jq '.statements[] | select(.vulnerability.aliases[]? | contains("CVE-2025-61729"))' fixed-report.json
# Should return empty (no match)
```

**Comparison Testing:**

```bash
# Compare before/after
echo "=== BEFORE (vulnerable) ==="
strings /tmp/<binary-name> | grep "go1\."
govulncheck --mode binary /tmp/<binary-name> 2>&1 | grep -E "CVE-2025-61729|CVE-2025-68121"

echo "=== AFTER (fixed) ==="
strings /tmp/maas-api-fixed | grep "go1\."
govulncheck --mode binary /tmp/maas-api-fixed 2>&1 | grep -E "CVE-2025-61729|CVE-2025-68121"
```

### Test Success Criteria

**Must Pass All:**
1. ✅ Binary scan shows target CVEs no longer present
2. ✅ Go version meets or exceeds minimum required for all CVE fixes
3. ✅ No new CVEs introduced by the update
4. ✅ Docker build completes successfully
5. ✅ Application starts and responds to health checks (if applicable)

**Functional Testing (if applicable):**
- API endpoints respond correctly
- Authentication/authorization works
- TLS connections establish properly (especially for crypto CVEs)
- Performance remains acceptable

**Regression Testing:**
- Existing integration tests pass
- No unexpected behavior changes
- Logs show no new errors or warnings

---

## Common Pitfalls

These are critical mistakes discovered during our CVE investigation. Avoid these to save time and ensure accurate results.

### Pitfall 1: Source Scanning Instead of Binary Scanning

**Problem:**

Using `govulncheck ./...` (source mode) to detect Go stdlib CVEs.

**Why It Fails:**

Source scanning analyzes:
- Import statements
- go.mod dependencies
- Reachable code paths

But it does NOT detect:
- What Go version the binary was compiled with
- What stdlib version is embedded in the binary

**Example of Misleading Result:**

```bash
# This will NOT detect Go stdlib version CVEs
cd /path/to/source
govulncheck ./...
# Output: "No vulnerabilities found"
# But the BINARY may still be vulnerable!
```

**Correct Approach:**

```bash
# ALWAYS use binary mode for stdlib CVEs
govulncheck --mode binary /path/to/compiled/binary
# This checks the actual Go runtime embedded in the binary
```

**When to Use Each Mode:**
- **Source mode** (`govulncheck ./...`): Checking dependency CVEs (e.g., AWS SDK, gRPC)
- **Binary mode** (`govulncheck --mode binary`): Checking stdlib CVEs or complete binary audit

**Rule of Thumb:** For Go version/stdlib CVEs, ALWAYS use binary mode.

### Pitfall 2: Assuming All Builds Use Same Dockerfile

**Problem:**

Updating only `maas-api/Dockerfile` but not `maas-api/Dockerfile.konflux`, assuming there's only one build configuration.

**Why It Fails:**

This repository has TWO Dockerfiles:
- `Dockerfile` → used for quay.io builds (development)
- `Dockerfile.konflux` → used for registry.redhat.io builds (production)

Updating only one leaves the other environment vulnerable.

**How to Avoid:**

```bash
# Always check for multiple Dockerfiles
find . -name "Dockerfile*" -type f

# Review each one to understand build strategy
cat maas-api/Dockerfile
cat maas-api/Dockerfile.konflux
```

**In Our Case:**
- Updated Dockerfile → quay.io fixed ✅
- Forgot Dockerfile.konflux → registry.redhat.io still vulnerable ⚠️

**Best Practice:** Document which Dockerfile is used for which registry/environment.

### Pitfall 3: Not Verifying Production Images

**Problem:**

Testing only locally built images or development images, not the actual production artifacts from registry.redhat.io.

**Why It Fails:**

Production builds may:
- Use different build configurations (Dockerfile.konflux vs Dockerfile)
- Have different base image versions
- Include additional layers or modifications by CI/CD

**How to Avoid:**

```bash
# ALWAYS test the actual published container
docker pull registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2

# Extract and scan the PRODUCTION binary
CONTAINER_ID=$(docker create registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/prod-binary
docker rm "$CONTAINER_ID"

govulncheck --mode binary /tmp/prod-binary
```

**Reality Check:** In our investigation, quay.io was fixed but registry.redhat.io was still vulnerable. Testing only one would have given incomplete results.

### Pitfall 4: Forgetting Both Registries/Environments

**Problem:**

Checking only quay.io OR registry.redhat.io, but not both.

**Why It Fails:**

Different registries may be in different states:
- Development registry (quay.io) gets updates faster
- Production registry (registry.redhat.io) uses pinned versions
- They can diverge significantly

**How to Avoid:**

Create a checklist for EVERY CVE investigation:

```bash
# 1. Check quay.io (development)
docker pull quay.io/opendatahub/maas-api:latest
# ... scan ...

# 2. Check registry.redhat.io (production)
docker pull registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2
# ... scan ...

# 3. Check other tags/versions if applicable
docker pull registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.3
# ... scan ...

# 4. Document results for ALL environments
```

**Template for Documentation:**

| Registry | Image:Tag | Go Version | CVE Status | Notes |
|----------|-----------|------------|------------|-------|
| quay.io | maas-api:latest | 1.25.7 | ✅ FIXED | Dev builds |
| registry.redhat.io | odh-maas-api-rhel9:v3.2 | 1.25.3 | ⚠️ AFFECTED | Prod v3.2 |
| registry.redhat.io | odh-maas-api-rhel9:v3.3 | TBD | ⏳ TESTING | Prod v3.3 |

### Pitfall 5: Using Outdated or Cached SHA Lookups

**Problem:**

Manually searching old commits or using cached/bookmarked SHA values instead of pulling fresh.

**Why It Fails:**

Red Hat frequently updates base images:
- Security patches released multiple times per month
- SHA values change with each update
- Old SHA values point to outdated, potentially vulnerable images

**How to Avoid:**

ALWAYS pull fresh and inspect:

```bash
# CORRECT: Pull fresh and get current SHA
docker pull registry.access.redhat.com/ubi9/go-toolset:1.25
docker inspect registry.access.redhat.com/ubi9/go-toolset:1.25 | jq -r '.[0].RepoDigests[0]'

# WRONG: Copying SHA from old commit or documentation
# (Don't do this - the SHA may be outdated)
```

**Verify the SHA's Go version:**

```bash
# ALWAYS verify what you're getting
docker run --rm registry.access.redhat.com/ubi9/go-toolset@sha256:<sha> go version

# Confirm it meets your security requirements
# e.g., >= Go 1.25.7 for our CVEs
```

**Best Practice:** Treat SHAs as ephemeral. Always derive them fresh from current tags.

### Pitfall 6: Delaying Security Updates

**Problem:**

Waiting for a "convenient time" or the next scheduled release to update SHAs, even when critical CVEs are disclosed.

**Why It's Bad:**

- Leaves production environments vulnerable
- Increases window of exposure
- May violate SLAs or compliance requirements
- Go stdlib CVEs often require no code changes, making delays unnecessary

**How to Avoid:**

Establish a **rapid response process** for Go stdlib CVEs:

**Timeline for Critical CVEs (CVSS >= 7.0):**
- Day 0: CVE announced
- Day 0-1: Assess impact on this project
- Day 1: Create fix PR (SHA update only)
- Day 2: Review, test, merge
- Day 2-3: Deploy to production

**For Go stdlib fixes:**
- No code changes usually required
- Testing is primarily verification (govulncheck scan)
- Can be fast-tracked compared to dependency updates

**When to Delay:**
- Only if the CVE doesn't affect our usage (e.g., unused stdlib package)
- Document the decision: "CVE-X in package Y, but we don't use Y"

**Example Policy:**

> "Go stdlib CVEs with CVSS >= 7.0 affecting packages we use SHALL be fixed within 48 hours of Red Hat publishing a fixed go-toolset image."

### Pitfall 7: Modifying go.mod Instead of Dockerfile.konflux SHA

**Problem:**

Using `govulncheck ./...` (source mode with `GOTOOLCHAIN`) on the source code, seeing CVEs reported, and then updating `go.mod` (e.g., `go 1.25` → `go 1.25.7`) as the fix — without checking what the actual build images use.

**Why It's Wrong:**

The `go` directive in `go.mod` is a **language compatibility marker**, not a security control. It specifies the minimum Go language version for syntax/API compatibility, but it does NOT control:
- What Go version the container image uses to compile the binary
- What Go stdlib is embedded in the production binary
- The security posture of the built artifact

The actual Go version in the binary is determined by:
- **Dockerfile** (dev builds): The floating tag (e.g., `:1.25`) — auto-updated by Red Hat
- **Dockerfile.konflux** (prod builds): The pinned SHA — requires manual update

**How This Mistake Happens:**

1. Run `GOTOOLCHAIN=go1.25.0 govulncheck ./...` on source code
2. See 14 stdlib CVEs reported (because GOTOOLCHAIN forces compilation with Go 1.25.0)
3. Assume the fix is to bump `go.mod` from `go 1.25` to `go 1.25.7`
4. Create a PR with go.mod changes
5. **Result:** Unnecessary PR that doesn't address the actual vulnerability in production builds

**The Misleading govulncheck Result:**

```bash
# This reports CVEs based on the Go version you TELL it to use,
# NOT the version the container actually builds with
GOTOOLCHAIN=go1.25.0 govulncheck ./...
# → "Your code is affected by 14 vulnerabilities"

# But if Dockerfile.konflux already has Go 1.25.7 SHA,
# the production binary is ALREADY FIXED
```

**Correct Approach — Always Check Dockerfile.konflux SHA First:**

```bash
# Step 1: Check what Go version the Dockerfile.konflux SHA contains
SHA=$(grep 'go-toolset@sha256:' maas-api/Dockerfile.konflux | grep -o 'sha256:[a-f0-9]*')
docker run --rm "registry.access.redhat.com/ubi9/go-toolset@$SHA" go version
# e.g., "go version go1.25.7" → ALREADY FIXED, no PR needed

# Step 2: Only if the SHA has a vulnerable Go version, update the SHA
# The fix is ALWAYS the SHA in Dockerfile.konflux, never go.mod
```

**Decision Tree:**

```
Is the Dockerfile.konflux SHA using a fixed Go version?
├── YES → Repository is ALREADY FIXED
│         → Document as already-fixed, do NOT create a PR
│         → Do NOT modify go.mod
└── NO  → Update the Dockerfile.konflux SHA
          → The fix is the SHA update, not go.mod
          → Optionally update go.mod if it makes sense for
            language compatibility, but this is NOT the CVE fix
```

**Real-World Example (February 2026):**

Upstream repo (`angaduom/models-as-a-service`):
- `go.mod`: `go 1.25`
- `Dockerfile.konflux`: SHA `799cc027...` = Go 1.25.7 ✅ ALREADY FIXED
- `Dockerfile`: floating `:1.25` tag = Go 1.25.7 ✅ ALREADY FIXED
- **Correct action:** Document as already fixed, skip PR creation
- **Mistake made:** Updated go.mod to `go 1.25.7` and created an unnecessary PR

Downstream repo (`angaduom/models-as-a-service-downstream`):
- `Dockerfile.konflux`: SHA `82b82ecf...` = Go 1.25.5 ⚠️ VULNERABLE
- **Correct action:** Update SHA to Go 1.25.7 (`799cc027...`) ✅ This was done correctly

**Key Takeaway:**

> For Go stdlib CVEs in this repository, the **only fix that matters** is the Dockerfile.konflux pinned SHA. The `go.mod` version is irrelevant to the security of production builds. Always check the SHA first — if it already contains the patched Go version, the repo is already fixed.

---

## Quick Reference Commands

### Binary Extraction from Container

**Extract binary from any container image:**

```bash
# Generic pattern
docker pull <registry>/<image>:<tag>
CONTAINER_ID=$(docker create <registry>/<image>:<tag>)
docker cp "$CONTAINER_ID:/app/<binary-name>" /tmp/<binary-name>
docker rm "$CONTAINER_ID"

# For maas-api production
docker pull registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2
CONTAINER_ID=$(docker create registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/maas-api-prod
docker rm "$CONTAINER_ID"

# For maas-api development
docker pull quay.io/opendatahub/maas-api:latest
CONTAINER_ID=$(docker create quay.io/opendatahub/maas-api:latest)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/maas-api-dev
docker rm "$CONTAINER_ID"
```

### Go Version Verification

**From binary:**

```bash
# Show Go version embedded in binary
strings /path/to/binary | grep "go1\."

# Example output:
# go1.25.7 (Red Hat 1.25.7-1.el9_7) X:strictfipsruntime
```

**From running container:**

```bash
# If Go toolchain is available in the container
docker run --rm <image>:<tag> go version

# Example:
docker run --rm registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2 go version
```

**From go-toolset base image SHA:**

```bash
# Verify what Go version a specific SHA contains
docker run --rm registry.access.redhat.com/ubi9/go-toolset@sha256:<sha> go version

# Example with our new SHA:
docker run --rm registry.access.redhat.com/ubi9/go-toolset@sha256:799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc go version
# Output: go version go1.25.7 linux/amd64
```

### CVE Scanning

**Binary mode (for Go stdlib CVEs) - PREFERRED:**

```bash
# Basic scan
govulncheck --mode binary /path/to/binary

# With OpenVEX format (machine-readable, good for automation)
govulncheck --mode binary --format openvex /path/to/binary > report.json

# Check for specific CVE in OpenVEX report
jq '.statements[] | select(.vulnerability.aliases[]? | contains("CVE-2025-61729"))' report.json

# Human-readable summary
govulncheck --mode binary /path/to/binary 2>&1 | grep -E "CVE-|Vulnerability|Found"
```

**Source mode (for dependency CVEs):**

```bash
# Scan source code and dependencies
cd /path/to/source
govulncheck ./...

# Scan specific package
govulncheck ./cmd/maas-api

# JSON output
govulncheck -json ./...
```

**Comparison scan (before/after fix):**

```bash
# Scan vulnerable version
govulncheck --mode binary /tmp/binary-before > before.txt

# Scan fixed version
govulncheck --mode binary /tmp/binary-after > after.txt

# Compare
diff before.txt after.txt
```

### SHA Lookup and Verification

**Get current SHA for a tag:**

```bash
# Pull latest tag
docker pull registry.access.redhat.com/ubi9/go-toolset:1.25

# Get SHA digest
docker inspect registry.access.redhat.com/ubi9/go-toolset:1.25 | jq -r '.[0].RepoDigests[0]'

# Output format:
# registry.access.redhat.com/ubi9/go-toolset@sha256:799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc
```

**Verify Go version in a SHA:**

```bash
# Run go version in the specific SHA
docker run --rm registry.access.redhat.com/ubi9/go-toolset@sha256:<sha> go version

# Full example:
docker run --rm registry.access.redhat.com/ubi9/go-toolset@sha256:799cc027d5ad58cdc156b65286eb6389993ec14c496cf748c09834b7251e78dc go version

# Output:
# go version go1.25.7 (Red Hat 1.25.7-1.el9_7) linux/amd64
```

**Get image creation date (to verify freshness):**

```bash
docker inspect registry.access.redhat.com/ubi9/go-toolset:1.25 | jq -r '.[0].Created'

# Or for a specific SHA:
docker inspect registry.access.redhat.com/ubi9/go-toolset@sha256:<sha> | jq -r '.[0].Created'
```

### Build Verification

**Build with specific Dockerfile:**

```bash
# Build using Dockerfile.konflux
docker build -f maas-api/Dockerfile.konflux -t maas-api:test .

# Build using regular Dockerfile
docker build -f maas-api/Dockerfile -t maas-api:dev .

# Build with specific platform
docker build --platform linux/amd64 -f maas-api/Dockerfile.konflux -t maas-api:test .
```

**Verify Go version in built image:**

```bash
# If go binary is available
docker run --rm maas-api:test go version

# If go is not in PATH but exists
docker run --rm maas-api:test /usr/bin/go version

# Extract and check binary (most reliable)
CONTAINER_ID=$(docker create maas-api:test)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/test-binary
docker rm "$CONTAINER_ID"
strings /tmp/test-binary | grep "go1\."
```

**Full verification workflow:**

```bash
# 1. Build
docker build -f maas-api/Dockerfile.konflux -t maas-api:verify .

# 2. Extract binary
CONTAINER_ID=$(docker create maas-api:verify)
docker cp "$CONTAINER_ID:/app/maas-api" /tmp/verify-binary
docker rm "$CONTAINER_ID"

# 3. Check Go version
strings /tmp/verify-binary | grep "go1\."

# 4. Scan for CVEs
govulncheck --mode binary /tmp/verify-binary

# 5. Clean up
rm /tmp/verify-binary
docker rmi maas-api:verify
```

### Git and PR Commands

**Fork and setup (one-time):**

```bash
# Fork the repository on GitHub
gh repo fork opendatahub-io/models-as-a-service --clone=false

# Add upstream remote (if working from existing fork clone)
git remote add upstream https://github.com/opendatahub-io/models-as-a-service.git
```

**Create fix branch from your fork:**

```bash
# Fetch latest from upstream
git fetch upstream

# Create branch from upstream main (or upstream/rhoai for backports)
git checkout -b fix/cve-YYYY-XXXXX-description upstream/main
```

**Commit with proper message:**

```bash
git add maas-api/Dockerfile.konflux
git commit -m "$(cat <<'EOF'
fix: cve-yyyy-xxxxx [brief description]

[detailed description of what and why in lowercase]

[explain the changes made]

verification:
- [list verification steps]

resolves: rhoaieng-xxxxx

co-authored-by: claude sonnet 4.5 <noreply@anthropic.com>
EOF
)"
```

**Push to your fork and create PR:**

```bash
# Push to your fork
git push -u origin fix/cve-YYYY-XXXXX-description

# Create PR from fork to upstream
gh pr create \
  --repo opendatahub-io/models-as-a-service \
  --base main \
  --head YOUR-USERNAME:fix/cve-YYYY-XXXXX-description \
  --title "fix: cve-yyyy-xxxxx [brief description]" \
  --body "$(cat <<'EOF'
## summary
[description in lowercase]

## cve details
- cve-yyyy-xxxxx: [description]

## changes
- [list of changes]

## test plan
- [x] [test step 1]
- [ ] [test step 2]

resolves: rhoaieng-xxxxx

generated with [claude code](https://claude.com/claude-code)
EOF
)"
```

---

## Repository-Specific Notes

### Build Environments

This repository has two distinct build environments:

#### 1. Development Environment (quay.io)

**Registry:** quay.io/opendatahub/maas-api
**Branch:** main
**Dockerfile:** `maas-api/Dockerfile`
**Base Image Strategy:** Floating tag (`:1.25`)
**Update Mechanism:** Automatic (when Red Hat updates tag)
**Primary Use:** Development, testing, preview builds
**Availability:** Public

**Characteristics:**
- Latest code from main branch
- Auto-receives security updates in base images
- May include experimental features
- Not intended for production use

#### 2. Production Environment (registry.redhat.io)

**Registry:** registry.redhat.io/rhoai/odh-maas-api-rhel9
**Branches:** rhoai, stable
**Dockerfile:** `maas-api/Dockerfile.konflux`
**Base Image Strategy:** Pinned SHA (`@sha256:...`)
**Update Mechanism:** Manual (requires PR to update SHA)
**Primary Use:** Red Hat OpenShift AI production releases
**Availability:** Requires Red Hat registry authentication

**Characteristics:**
- Official RHOAI release builds
- Reproducible builds via pinned SHAs
- Follows Red Hat release cadence
- Requires explicit approval for base image updates

### When to Update Which Dockerfile

**Update `maas-api/Dockerfile` when:**
- Changing development base image tag
- Testing new Go versions in development
- Updating floating tag version (e.g., `:1.25` → `:1.26`)

**Update `maas-api/Dockerfile.konflux` when:**
- Fixing CVEs in production builds
- Updating Go version for official releases
- Syncing with security patches
- Preparing for new RHOAI version release

**Update BOTH when:**
- Major Go version bump (e.g., Go 1.25 → 1.26)
- Comprehensive security updates affecting all environments
- Standardizing base images across all builds

**Target Branches:**

| Change Type | Branch | Dockerfile | Reason |
|-------------|--------|-----------|--------|
| CVE fix for next release | main | Dockerfile.konflux | Prepares v3.3+ |
| CVE backport to v3.2 | rhoai or stable | Dockerfile.konflux | Fixes current production |
| Dev environment update | main | Dockerfile | Development only |
| Comprehensive fix | main + rhoai/stable | Both | All environments |

### Branch Strategy

**Development Branch (main):**
- Contains latest features and fixes
- Builds automatically to quay.io
- Target for v3.3+ features
- Fast-moving, frequent updates

**Production Branches (rhoai, stable):**
- Contain stable, released code
- Builds to registry.redhat.io
- Target for backports and security fixes
- Slower-moving, controlled updates

**Creating PRs:**

**Important:** Always use a fork workflow, not direct branches on the upstream repository.

For next release (v3.3+):
```bash
# One-time setup: Fork the repo and add upstream
gh repo fork opendatahub-io/models-as-a-service --clone=false
git remote add upstream https://github.com/opendatahub-io/models-as-a-service.git

# For each PR: Create branch from upstream, work, and push to fork
git fetch upstream
git checkout -b fix/cve-issue upstream/main
# ... make changes ...
git push -u origin fix/cve-issue
gh pr create --repo opendatahub-io/models-as-a-service --base main --head YOUR-USERNAME:fix/cve-issue
```

For backport to current release (v3.2):
```bash
# Create branch from upstream rhoai or stable
git fetch upstream
git checkout -b backport/cve-issue-v3.2 upstream/rhoai  # or upstream/stable
# ... make changes ...
git push -u origin backport/cve-issue-v3.2
gh pr create --repo opendatahub-io/models-as-a-service --base rhoai --head YOUR-USERNAME:backport/cve-issue-v3.2
```

For comprehensive fix (both):
1. Create PR from fork targeting upstream main
2. After merge, cherry-pick to your fork's backport branch, then PR to upstream rhoai/stable
3. Or create separate PRs from your fork for each upstream branch

### Historical Go Version Updates

**Table of SHA Updates:**

| Date | Commit | Old Version | New Version | Old SHA (first 12 chars) | New SHA (first 12 chars) | Reason |
|------|--------|-------------|-------------|-------------------------|-------------------------|--------|
| Dec 15, 2025 | 3cf4c9b | Go 1.24 | Go 1.25.3 | N/A (tag-based) | eaa6e2e56093 | Bump to Go 1.25 |
| Feb 19, 2026 | TBD | Go 1.25.3 | Go 1.25.7 | eaa6e2e56093 | 799cc027d5ad | CVE-2025-61729, CVE-2025-68121 |

**Update Template (for future use):**

```markdown
| [Date] | [Commit Hash] | Go [X.Y.Z] | Go [A.B.C] | [old-sha-12] | [new-sha-12] | [CVE-YYYY-XXXXX, ...] |
```

**Commit References:**
- Commit 3cf4c9b: Initial bump to Go 1.25, introduced Dockerfile.konflux pinned SHA strategy
- Pull Request #316: "build: bumps go to 1.25" by Bartosz Majsak

### Registry Authentication

**For quay.io (public):**
```bash
# No authentication needed for public images
docker pull quay.io/opendatahub/maas-api:latest
```

**For registry.redhat.io (requires Red Hat account):**
```bash
# Login with Red Hat credentials
docker login registry.redhat.io
Username: <your-red-hat-account>
Password: <your-password-or-token>

# Then pull
docker pull registry.redhat.io/rhoai/odh-maas-api-rhel9:v3.2
```

**Service Account (for CI/CD):**
- Use Red Hat registry service account tokens
- Configure in CI/CD secret management
- Reference: https://access.redhat.com/terms-based-registry/

### Common Image Tags

**quay.io/opendatahub/maas-api:**
- `latest`: Latest build from main branch
- `v0.0.x`: Older version tags
- `pr-XXX`: Pull request preview builds (if configured)

**registry.redhat.io/rhoai/odh-maas-api-rhel9:**
- `v3.2`: RHOAI 3.2 release
- `v3.3`: RHOAI 3.3 release (upcoming)
- `latest`: May not exist or may not be current

**Always verify the tag you're testing matches production.**

---

## Additional CVE Fix Patterns

This section will be expanded with additional CVE fix patterns as they are encountered in this repository.

### Pattern Template

For consistency, future CVE fixes should be documented using this template:

```markdown
## Pattern N: [CVE Category Name]

### Overview

**Frequency:** [Common/Occasional/Rare]
**Fix Complexity:** [Low/Medium/High]
**Critical Insight:** [Key learning]

### Historical Example: CVE-YYYY-XXXXX ([Date])

**Date:** [Month Year]
**Jira Tickets:** [TICKET-IDs]
**Affected Packages:** [Package names and versions]
**Fix Version:** [Fixed version]
**Resolution:** [Summary of fix]

#### CVE Details
[Details about the CVE]

#### Problem Description
[What was the issue]

#### Root Cause Analysis
[Why it happened]

#### Step-by-Step Fix Procedure
[Numbered steps with code examples]

### Testing Requirements
[How to verify]

### Common Pitfalls
[Mistakes to avoid]
```

### Placeholder for Future Patterns

**Anticipated patterns may include:**

- Pattern 2: Dependency CVEs (e.g., gRPC, AWS SDK, Kubernetes client)
- Pattern 3: Base Image CVEs (UBI9 vulnerabilities)
- Pattern 4: Build Tool CVEs (Docker, Konflux, CI/CD)
- Pattern 5: Runtime CVEs (Kubernetes, OpenShift components)

These will be added as they are encountered and documented.

---

## Resources and References

### Go Security Resources

- **Go Security Policy:** https://go.dev/security/policy
- **Go Vulnerability Database:** https://pkg.go.dev/vuln/
- **Go Announcements:** https://groups.google.com/g/golang-announce
- **govulncheck Documentation:** https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck

### Red Hat Resources

- **Red Hat Security Advisories:** https://access.redhat.com/security/security-updates/
- **UBI Documentation:** https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/building_running_and_managing_containers/
- **Red Hat Registry:** https://catalog.redhat.com/
- **go-toolset Container:** https://catalog.redhat.com/software/containers/ubi9/go-toolset/

### Repository Resources

- **GitHub Repository:** https://github.com/opendatahub-io/models-as-a-service
- **RHOAI Documentation:** https://access.redhat.com/documentation/en-us/red_hat_openshift_ai_cloud_service/
- **Build System (Konflux):** [Internal Red Hat documentation]

### Tools

- **govulncheck:** `go install golang.org/x/vuln/cmd/govulncheck@latest`
- **jq:** https://jqlang.github.io/jq/
- **Docker:** https://docs.docker.com/
- **GitHub CLI (gh):** https://cli.github.com/

---

## Document Maintenance

**Last Updated:** February 19, 2026
**Maintained By:** RHOAI Security Team / CVE Fixer Workflow
**Review Frequency:** Quarterly or after major CVE fixes

**Update Process:**
1. When a new CVE is fixed, document it in the appropriate pattern section
2. Add any new pitfalls or learnings discovered
3. Update the Historical Go Version Updates table
4. Review quick reference commands for accuracy
5. Update "Last Updated" date

**Feedback:**
If you discover additional patterns, pitfalls, or have improvements to this documentation, please:
1. Add notes to the relevant JIRA ticket
2. Create a PR updating this file
3. Share learnings with the team in security retrospectives

---

**Generated by:** CVE Fixer Workflow (`/cve.fix` command)
**Purpose:** Provide repository-specific guidance for CVE remediation
**Integration:** Automatically loaded by `/cve.fix` workflow in Step 4.5

---
